Project Root: C:\Dev\lexic-main

Folder Structure:
=================
lexic-main/
├── .eslintrc.json
├── .gitignore
├── codebase.txt
├── components.json
├── next.config.js
├── package.json
├── postcss.config.mjs
├── tailwind.config.ts
├── tsconfig.json
├── app/
│   ├── globals.css
│   ├── layout.tsx
│   ├── page.tsx
│   ├── api/
│   │   ├── game/
│   │   │   ├── route.ts
│   │   ├── validate/
│   │   │   ├── route.ts
├── components/
│   ├── game/
│   │   ├── Board.tsx
│   │   ├── Cell.tsx
│   │   ├── GameBoard.tsx
│   │   ├── Keyboard.tsx
│   │   ├── StatsCard.tsx
│   ├── layout/
│   │   ├── Game.tsx
│   │   ├── MainMenu.tsx
│   ├── stats/
│   │   ├── DetailedStats.tsx
│   ├── ui/
│   │   ├── LanguageFlag.tsx
│   │   ├── Loader.tsx
│   │   ├── SettingsDialog.tsx
│   │   ├── Title.tsx
│   │   ├── button.tsx
│   │   ├── card.tsx
│   │   ├── dialog.tsx
│   │   ├── particles-background.tsx
│   │   ├── toast.tsx
│   │   ├── toaster.tsx
├── hooks/
│   ├── use-toast.ts
│   ├── useKeyboardControls.ts
│   ├── game/
│   │   ├── useGameEffects.ts
│   │   ├── useGameInput.ts
│   │   ├── useGameLogic.ts
│   ├── stats/
│   │   ├── useGameStats.ts
├── lib/
│   ├── utils.ts
│   ├── game/
│   │   ├── constants.ts
│   │   ├── validation.ts
│   │   ├── words.ts
│   ├── i18n/
│   │   ├── translations.ts
│   ├── stats/
│   │   ├── statsManager.ts
│   ├── types/
│   │   ├── game.ts
│   │   ├── i18n.ts
│   │   ├── keyboard.ts
│   ├── utils/
│   │   ├── animations.ts
│   │   ├── keyboard.ts
│   │   ├── storage.ts


File Contents:
==============

--- File: .eslintrc.json (Words (approx tokens): 5) ---
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}

--- End of File: .eslintrc.json ---

--- File: .gitignore (Words (approx tokens): 54) ---
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files (can opt-in for commiting if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

--- End of File: .gitignore ---

--- File: codebase.txt (Words (approx tokens): 0) ---

--- End of File: codebase.txt ---

--- File: components.json (Words (approx tokens): 38) ---
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
--- End of File: components.json ---

--- File: next.config.js (Words (approx tokens): 17) ---
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
};

export default nextConfig;

--- End of File: next.config.js ---

--- File: package.json (Words (approx tokens): 85) ---
{
  "name": "lexic",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.2",
    "@shadcn/ui": "^0.0.4",
    "an-array-of-english-words": "^2.0.0",
    "an-array-of-french-words": "^2.0.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "framer-motion": "^11.11.11",
    "lucide-react": "^0.454.0",
    "next": "^14.2.16",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-tsparticles": "^2.12.2",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "tsparticles": "^3.9.1",
    "tsparticles-slim": "^2.12.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "15.0.2",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

--- End of File: package.json ---

--- File: postcss.config.mjs (Words (approx tokens): 17) ---
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

--- End of File: postcss.config.mjs ---

--- File: tailwind.config.ts (Words (approx tokens): 104) ---
import type { Config } from "tailwindcss";

const config: Config = {
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			correct: 'rgb(var(--correct) / <alpha-value>)',
  			present: 'rgb(var(--present) / <alpha-value>)',
  			absent: 'rgb(var(--absent) / <alpha-value>)',
  		},
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
--- End of File: tailwind.config.ts ---

--- File: tsconfig.json (Words (approx tokens): 52) ---
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

--- End of File: tsconfig.json ---

--- File: app/globals.css (Words (approx tokens): 458) ---
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Base */
    --background: 231 23% 11%;
    --foreground: 0 0% 98%;

    /* Game Colors */
--correct: 22 163 74; 
--present: 202 138 4;  
--absent: 51 65 85;  
    
    /* UI Colors */
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 2%;
    
    --secondary: 240 5.9% 90%;
    --secondary-foreground: 0 0% 2%;
    

    --accent: 195 35% 32%;
    --accent-foreground: 0 0% 98%;
    
    --muted: 222 20% 28%;
    --muted-foreground: 240 5.9% 70%;

    /* UI Elements */
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 356 100% 45%;

    --radius: 0.5rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer components {
  .moving-lights {
    @apply fixed inset-0 z-0 overflow-hidden;
  }

  .moving-lights::before,
  .moving-lights::after {
    content: '';
    @apply absolute -inset-[150px];
    @apply rounded-[50%];
    @apply opacity-70;
    @apply mix-blend-soft-light;
    @apply filter blur-[100px];
    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform;
    transform-origin: center;
  }

  .moving-lights::before {
    background: rgb(var(--accent));
    animation: blob-1 20s infinite;
  }

  .moving-lights::after {
    background: rgb(var(--muted));
    animation: blob-2 30s infinite;
  }

  .bg-animate {
    animation: backgroundShift 15s ease infinite;
    background-size: 400% 400%;
    background-image: linear-gradient(
      45deg,
      hsl(var(--background)),
      hsl(var(--muted)),
      hsl(var(--background))
    );
  }

  .ambient-background {
    @apply fixed inset-0 z-[-1] overflow-hidden;
  }

  .ambient-background::before,
  .ambient-background::after,
  .ambient-background .blob {
    content: '';
    @apply absolute rounded-full opacity-30 mix-blend-soft-light filter blur-[80px];
    width: 800px;
    height: 800px;
    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    animation-iteration-count: infinite;
    will-change: transform;
  }

  .ambient-background::before {
    background: hsl(var(--accent));
    animation: float-blob-1 20s infinite;
    left: 10%;
    top: 10%;
  }

  .ambient-background::after {
    background: hsl(var(--muted));
    animation: float-blob-2 25s infinite;
    right: 10%;
    bottom: 10%;
  }
}

@keyframes blob-1 {
  0%, 100% {
    transform: translate(-40%, -40%) scale(1);
  }
  25% {
    transform: translate(40%, 40%) scale(1.2);
  }
  50% {
    transform: translate(40%, -40%) scale(1);
  }
  75% {
    transform: translate(-40%, 40%) scale(1.2);
  }
}

@keyframes blob-2 {
  0%, 100% {
    transform: translate(40%, 40%) scale(1);
  }
  25% {
    transform: translate(-40%, -40%) scale(1.2);
  }
  50% {
    transform: translate(-40%, 40%) scale(1);
  }
  75% {
    transform: translate(40%, -40%) scale(1.2);
  }
}

@keyframes backgroundShift {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

@keyframes float-blob-1 {
  0%, 100% {
    transform: translate(0, 0) scale(1);
  }
  25% {
    transform: translate(100px, 50px) scale(1.2);
  }
  50% {
    transform: translate(50px, 100px) scale(0.8);
  }
  75% {
    transform: translate(-50px, 50px) scale(1.1);
  }
}

@keyframes float-blob-2 {
  0%, 100% {
    transform: translate(0, 0) scale(1);
  }
  25% {
    transform: translate(-100px, -50px) scale(0.9);
  }
  50% {
    transform: translate(-50px, -100px) scale(1.2);
  }
  75% {
    transform: translate(50px, -50px) scale(0.8);
  }
}

.reduce-banding {
  @apply relative;
  &::after {
    content: '';
    @apply fixed inset-0;
    @apply pointer-events-none;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
    opacity: 0.02;
    mix-blend-mode: overlay;
  }
}

--- End of File: app/globals.css ---

--- File: app/layout.tsx (Words (approx tokens): 91) ---
// layout.tsx
import './globals.css';
import { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { cn } from '@/lib/utils';
import { Toaster } from '@/components/ui/toaster';
import ParticlesBackground from '@/components/ui/particles-background';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Lexic',
  description: 'A modern wordle clone',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={cn(
        inter.className,
        "min-h-[100dvh] bg-background font-sans antialiased relative"
      )} suppressHydrationWarning={true}>
        <ParticlesBackground />
        <div className="relative z-10">
          {children}
        </div>
        <Toaster />
      </body>
    </html>
  );
}
--- End of File: app/layout.tsx ---

--- File: app/page.tsx (Words (approx tokens): 15) ---
import { Game } from '@/components/layout/Game';

export default function Home() {
  return <Game />;
} 
--- End of File: app/page.tsx ---

--- File: app/api/game/route.ts (Words (approx tokens): 146) ---
import { NextResponse } from 'next/server';
import { getRandomWord, getWordOfTheDay } from '@/lib/game/words';
import { cookies } from 'next/headers';
import { GameMode } from '@/lib/types/game';

export async function POST(request: Request) {
  try {
    const { action, language = 'en', gameMode = 'infinite' } = await request.json();
    
    if (action === 'new') {
      let word: string;
      switch(gameMode as GameMode) {
        case 'wordOfTheDay':
          word = getWordOfTheDay(language);
          break;
        case 'todaysSet': // For now, same as infinite
        case 'infinite':
        default:
          word = getRandomWord(language);
          break;
      }
      
      const length = word.length;
      
      // Store word in httpOnly cookie 
      cookies().set('gameWord', word, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
      });
      
      return NextResponse.json({
        success: true,
        length: length,
        firstLetter: word.charAt(0).toLowerCase(),
      });
    }
    
    return NextResponse.json({ success: false, error: 'invalidAction' });
  } catch (e) {
    const error = e as Error;
    console.error("Failed to start new game:", error.message);
    return NextResponse.json({ 
      success: false, 
      error: 'failedToStart' 
    }, { status: 500 });
  }
}
--- End of File: app/api/game/route.ts ---

--- File: app/api/validate/route.ts (Words (approx tokens): 116) ---
import { NextResponse } from 'next/server';
import { validateGuess, getLetterStates, normalizeWord } from '@/lib/game/validation';
import { cookies } from 'next/headers';
import { TRIES } from '@/lib/game/constants';

export async function POST(request: Request) {
  const { guess, language = 'en', guessCount } = await request.json();
  
  const answer = cookies().get('gameWord')?.value;
  if (!answer) {
    return NextResponse.json({ 
      isValid: false, 
      message: 'noActiveGame'
    });
  }
  
  const validation = validateGuess(guess, answer.length, language);
  
  if (!validation.isValid) {
    return NextResponse.json({ 
      isValid: false, 
      message: validation.message || 'notInWordList'
    });
  }
  
  const letterStates = getLetterStates(guess, answer);
  const isCorrect = normalizeWord(guess.toLowerCase()) === normalizeWord(answer.toLowerCase());
  const isGameOver = isCorrect || guessCount >= TRIES - 1; 
  
  return NextResponse.json({
    isValid: true,
    letterStates,
    isCorrect,
    answer: isGameOver ? answer : undefined,
    guessCount: guessCount + 1
  });
} 
--- End of File: app/api/validate/route.ts ---

--- File: components/game/Board.tsx (Words (approx tokens): 200) ---
import { motion } from 'framer-motion';
import { type LetterState, type GuessResult } from '@/lib/types/game';
import { Cell } from '@/components/game/Cell';
import { ANIMATIONS } from '@/lib/utils/animations';
import { TRIES } from '@/lib/game/constants';

interface BoardProps {
  guesses: GuessResult[];
  currentGuess: string;
  wordLength: number;
  shake: boolean;
  initialStates?: LetterState[];
}

export function Board({ guesses, currentGuess, wordLength, shake, initialStates }: BoardProps) {
  if (!wordLength) return null;

  return (
    <div className="w-full max-w-[var(--game-max-width)] mx-auto pt-2">
      <div className="grid gap-1 place-items-center mb-4">
        {Array(TRIES).fill(null).map((_, i) => {
          if (i < guesses.length) {
            return (
              <Row 
                key={i} 
                word={guesses[i].word}
                states={guesses[i].letterStates}
                wordLength={wordLength}
              />
            );
          }
          if (i === guesses.length) {
            return (
              <Row 
                key={i}
                word={currentGuess}
                states={guesses.length === 0 ? initialStates! : Array(wordLength).fill('empty')}
                wordLength={wordLength}
                isActive={true}
                shake={shake}
              />
            );
          }
          return (
            <Row 
              key={i}
              word=""
              states={Array(wordLength).fill('empty')}
              wordLength={wordLength}
            />
          );
        })}
      </div>
    </div>
  );
}

interface RowProps {
  word: string;
  states: LetterState[];
  wordLength: number;
  isActive?: boolean;
  shake?: boolean;
}

function Row({ word, states, wordLength, isActive = false, shake = false }: RowProps) {
  const cells = Array(wordLength).fill('').map((_, i) => word[i] || '');

  return (
    <motion.div 
      className="flex" 
      animate={shake ? ANIMATIONS.SHAKE : {}}
      transition={{ duration: 0.3, type: "spring", stiffness: 400 }}
    >
      {cells.map((letter, i) => (
        <Cell 
          key={i}
          letter={letter}
          state={states[i]}
          isActive={isActive}
          delay={i}
        />
      ))}
    </motion.div>
  );
}
--- End of File: components/game/Board.tsx ---

--- File: components/game/Cell.tsx (Words (approx tokens): 159) ---
import { motion } from 'framer-motion';
import { cn } from '@/lib/utils';
import { ANIMATIONS } from '@/lib/utils/animations';
import { LetterState } from '@/lib/types/game';

interface CellProps {
  letter: string;
  state: LetterState;
  isActive?: boolean;
  delay?: number;
  size?: 'normal' | 'large';
}

const cellStateStyles = {
  correct: 'bg-correct text-foreground border-primary',
  present: 'bg-present text-foreground border-primary',
  absent: 'bg-transparent text-foreground border-primary',
  empty: 'bg-transparent border-primary/30'
} as const;

export function Cell({ 
  letter, 
  state, 
  isActive = false,
  delay = 0,
  size = 'normal'
}: CellProps) {
  const baseStyles = cn(
    "flex items-center justify-center",
    "font-bold",
    "border-2 rounded-md",
    "select-none",
    "transition-colors duration-300",
    "text-foreground",
    size === 'normal' ? "w-14 h-14 text-2xl" : "w-20 h-20 text-4xl",
    state === 'empty' && isActive && letter 
      ? 'border-primary shadow-sm' 
      : 'border-primary/30',
    cellStateStyles[state]
  );

  return (
    <motion.div 
      className={baseStyles}
      animate={{
        scale: letter ? 1 : 0.95,
        rotateX: state !== 'empty' ? ANIMATIONS.FLIP.rotateX : 0
      }}
      transition={{
        duration: ANIMATIONS.FLIP.duration,
        delay: state !== 'empty' ? delay * 0.1 : 0,
        ease: "easeInOut"
      }}
    >
      {letter.toUpperCase()}
    </motion.div>
  );
} 
--- End of File: components/game/Cell.tsx ---

--- File: components/game/GameBoard.tsx (Words (approx tokens): 194) ---
import { Board } from './Board';
import Keyboard from './Keyboard';
import { StatsCard } from './StatsCard';
import { GuessResult, type GameStats, GameMode, LetterState } from '@/lib/types/game';
import { type KeyState, KeyboardLayout } from '@/lib/types/keyboard';
import { type Language } from '@/lib/types/i18n';
import { Loader } from '@/components/ui/Loader';

interface GameBoardProps {
  guesses: GuessResult[];
  currentGuess: string;
  wordLength: number;
  shake: boolean;
  showStats: boolean;
  stats: GameStats;
  gameOver: boolean;
  keyStates: Record<string, KeyState>;
  onKeyPress: (key: string) => void;
  onNewGame: () => void;
  keyboardLayout: KeyboardLayout;
  revealedAnswer: string | null;
  language: Language;
  isSubmitting: boolean;
  isLoading: boolean;
  gameMode: GameMode;
  initialStates?: LetterState[]; // This line was missing
}

export function GameBoard({
  guesses,
  currentGuess,
  wordLength,
  shake,
  showStats,
  stats,
  gameOver,
  keyStates,
  onKeyPress,
  onNewGame,
  keyboardLayout,
  revealedAnswer,
  language,
  isSubmitting,
  isLoading,
  initialStates, 
}: GameBoardProps) {
  if (isLoading) {
    return (
      <div className="flex flex-grow items-center justify-center">
        <Loader />
      </div>
    );
  }

  return (
    <div className="relative flex flex-col justify-center w-full">
      <div className="w-full max-w-[480px] mx-auto flex flex-col items-center">
        <Board
          guesses={guesses}
          currentGuess={currentGuess}
          wordLength={wordLength}
          shake={shake}
          initialStates={initialStates} // And passed down
        />
        <div className="w-full pb-4">
          <Keyboard
            onKey={onKeyPress}
            keyStates={keyStates}
            keyboardLayout={keyboardLayout}
            isSubmitting={isSubmitting}
          />
        </div>
      </div>

      {showStats && (
        <StatsCard
          stats={stats}
          gameOver={gameOver}
          guesses={guesses}
          onNewGame={onNewGame}
          revealedAnswer={revealedAnswer}
          language={language}
          className="lg:absolute lg:top-0 lg:left-full lg:ml-4 mt-4 lg:mt-0 mx-auto"
        />
      )}
    </div>
  );
}
--- End of File: components/game/GameBoard.tsx ---

--- File: components/game/Keyboard.tsx (Words (approx tokens): 170) ---
'use client';

import { motion } from 'framer-motion';
import { KeyboardLayout, KEYBOARD_LAYOUTS, KeyState } from '@/lib/types/keyboard';
import { KEYBOARD_ANIMATIONS } from '@/lib/utils/animations';

interface KeyboardProps {
  keyStates: Record<string, KeyState>;
  onKey: (key: string) => void;
  keyboardLayout: KeyboardLayout;
  isSubmitting: boolean;
  isUppercase?: boolean;
}

export default function Keyboard({
  keyStates,
  onKey,
  keyboardLayout,
  isSubmitting,
  isUppercase = true
}: KeyboardProps) {
  const stateStyles = {
    correct: 'bg-correct/100 hover:bg-correct/80 text-white ',
    present: 'bg-present/100 hover:bg-present/80 text-white',
    absent: 'bg-primary/10 hover:bg-primary/30 text-primary/60',
    unused: 'bg-primary/5 hover:bg-primary/30 text-white border border-white/50'
  } as const;

  return (
    <div className="w-full max-w-[500px] mx-auto px-2">
      {KEYBOARD_LAYOUTS[keyboardLayout].map((row, i) => (
        <div key={i} className="flex justify-center gap-1 my-1">
          {row.map((keyObj) => {
            const keyLabel = isUppercase ? keyObj.key.toUpperCase() : keyObj.key.toLowerCase();
            const state = (keyStates[keyObj.key.toLowerCase()] || 'unused') as keyof typeof stateStyles;
            const isSpecialKey = keyObj.key === 'Enter' || keyObj.key === 'Backspace';

            return (
              <motion.button
                key={keyObj.key}
                onClick={() => onKey(keyObj.key)}
                whileTap={KEYBOARD_ANIMATIONS.PRESS}
                className={`
                  rounded-lg
                  font-bold 
                  select-none
                  transition-all
                  shadow-sm
                  ${stateStyles[state]}
                  ${isSpecialKey ? 'px-2 text-sm' : 'w-[2.2rem] sm:w-10'} 
                  h-11 sm:h-14 
                `}
                disabled={isSubmitting}
              >
                {keyObj.key === 'Backspace' ? '←' : keyLabel}
              </motion.button>
            );
          })}
        </div>
      ))}
    </div>
  );
}

--- End of File: components/game/Keyboard.tsx ---

--- File: components/game/StatsCard.tsx (Words (approx tokens): 357) ---
import { GameStats, GuessResult } from '@/lib/types/game';
import { Search } from "lucide-react";
import { Button } from "@/components/ui/button";
import { t } from '@/lib/i18n/translations';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from 'framer-motion';
import React from 'react';
import { Language } from '@/lib/types/i18n';
import { ANIMATIONS, STATS_ANIMATIONS } from '@/lib/utils/animations';
import { Keyboard } from "lucide-react";

interface StatsCardProps {
  stats: GameStats;
  gameOver: boolean;
  guesses: GuessResult[];
  onNewGame: () => void;
  revealedAnswer?: string | null;
  language: Language;
  className?: string;
}

const Stats = React.memo(({ 
  label, 
  value, 
}: { 
  label: string; 
  value: number; 
  highlight?: boolean;
}) => (
  <motion.div 
    className={cn(
      "text-center p-4 rounded-lg",
    )}
    initial={STATS_ANIMATIONS.COUNT.initial}
    animate={STATS_ANIMATIONS.COUNT.animate}
    transition={STATS_ANIMATIONS.COUNT.transition}
  >
    <motion.div className="text-2xl font-bold text-primary">
      {Math.round(value)}
    </motion.div>
    <div className="text-sm text-primary/50">{label}</div>
  </motion.div>
));

Stats.displayName = 'Stats';

export function StatsCard({ 
  stats, 
  gameOver, 
  guesses, 
  onNewGame, 
  revealedAnswer,
  language,
  className 
}: StatsCardProps) {
  const isWon = guesses.length > 0 && guesses[guesses.length - 1].isCorrect;
  const winPercentage = stats.gamesPlayed > 0 
    ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100)
    : 0;

  const handleSearch = () => {
    if (revealedAnswer) {
      window.open(`https://www.google.com/search?q=${revealedAnswer}+definition`, '_blank');
    }
  };

  return (
    <AnimatePresence>
      {gameOver && stats && (
        <motion.div
          {...ANIMATIONS.REVEAL}
          className={cn(
            "flex items-center justify-center ",
            className
          )}
        >
          <motion.div 
            className="bg-transparent p-6 max-w-2xl w-full mx-4"
            initial={{ y: -20, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            exit={{ y: -20, opacity: 0 }}
            transition={{ duration: 0.3 }}
          >
            <div className="text-center mb-8">
              <h2 className="text-2xl font-bold mb-2 text-primary">
                {isWon ? t('youWon', language) : t('gameOver', language)}
              </h2>
              {gameOver && !isWon && revealedAnswer && (
                <p className="text-lg text-primary">
                  {t('answer', language, { word: revealedAnswer })}
                  <button
                    onClick={handleSearch}
                    className="inline-flex items-center ml-2 text-muted-foreground hover:text-primary"
                    title={t('searchDefinition', language)}
                  >
                    <Search size={16} />
                  </button>
                </p>
              )}
            </div>

            <div className="grid grid-cols-2 gap-6 mb-8">
              <Stats 
                label={t('streak', language)} 
                value={stats.currentStreak}
                highlight={stats.currentStreak > 0}
              />
              <Stats 
                label={t('maxStreak', language)} 
                value={stats.maxStreak}
                highlight={stats.currentStreak === stats.maxStreak && stats.maxStreak > 0}
              />
              <Stats 
                label={t('gamesPlayed', language)} 
                value={stats.gamesPlayed} 
              />
              <Stats 
                label={t('winPercentage', language)} 
                value={winPercentage} 
              />
            </div>

            <div className="flex justify-center gap-6 flex-col items-center">
              <Button
                onClick={onNewGame}
                variant="outline"
                className="w-48 py-3 text-white rounded-lg font-bold"
              >
                {t('newGame', language)}
              </Button>
              
              <motion.div 
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 0.5 }}
                className="flex items-center gap-2 text-sm text-muted-foreground mt-2"
              >
                <Keyboard size={16} />
                {t('pressEnterNewGame', language)}
              </motion.div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
} 
--- End of File: components/game/StatsCard.tsx ---

--- File: components/layout/Game.tsx (Words (approx tokens): 684) ---
'use client';

import { useState, useEffect, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import { MainMenu } from '@/components/layout/MainMenu';
import { GameBoard } from '@/components/game/GameBoard';
import { useGameLogic } from '@/hooks/game/useGameLogic';
import { useGameEffects } from '@/hooks/game/useGameEffects';
import { useGameStats } from '@/hooks/stats/useGameStats';
import { useToast } from '@/hooks/use-toast';
import { Button } from "@/components/ui/button";
import { Home } from 'lucide-react';
import { Card } from '../ui/card';
import { t } from '@/lib/i18n/translations';
import { Language, TranslationKey } from '@/lib/types/i18n';
import { GameMode, LetterState } from '@/lib/types/game';
import { loadGameState, saveGameState, saveDailyGameState, loadDailyGameState, clearDailyGameState, loadLanguagePreference, saveLanguagePreference } from '@/lib/utils/storage';
import { KeyboardLayout, KeyState } from '@/lib/types/keyboard';
import { getKeyboardState } from '@/lib/utils/keyboard';

export function Game() {
  const [showMenu, setShowMenu] = useState(true);
  const [language, setLanguage] = useState<Language>(() => loadLanguagePreference());
  const [isPlaying, setIsPlaying] = useState(false);
  const [gameMode, setGameMode] = useState<GameMode>('infinite');
  const [keyboardLayout, setKeyboardLayout] = useState<KeyboardLayout>(() => {
    const userSavedLayout = loadGameState<KeyboardLayout | null>('keyboardLayout', null);
    if (userSavedLayout) {
      return userSavedLayout;
    }
    const initialLanguage = loadLanguagePreference();
    return initialLanguage === 'fr' ? 'azerty' : 'qwerty';
  });
  const [shake, setShake] = useState(false);
  const [showStatsCard, setShowStatsCard] = useState(false);
  const [keyStates, setKeyStates] = useState<Record<string, KeyState>>({});

  const { toast } = useToast();
  const { stats } = useGameStats({ gameMode });

  const {
    wordLength,
    guesses,
    currentGuess,
    gameOver,
    isSubmitting,
    isLoading,
    revealedAnswer,
    submitGuess,
    updateCurrentGuess,
    newGame,
    resetGame,
    loadInProgressGame,
  } = useGameLogic({ language });

  const handleStartGame = useCallback(async (mode: GameMode) => {
    setGameMode(mode);
    setShowStatsCard(false);
    setShowMenu(false);
    setIsPlaying(true);
    
    const isDailyMode = mode === 'wordOfTheDay' || mode === 'todaysSet';

    if (isDailyMode) {
      const savedState = loadDailyGameState(mode);
      const today = new Date().toDateString();

      if (savedState && savedState.date === today) {
        const result = await newGame({ gameMode: mode });
        if (result.success) {
          loadInProgressGame(savedState);
        } else {
          toast({
            title: t('error', language),
            description: result.error || t('failedToStart', language),
            duration: 2000
          });
        }
        return;
      } else if (savedState) {
        clearDailyGameState(mode);
      }
    }

    const result = await newGame({ gameMode: mode });
    if (!result.success) {
      toast({
        title: t('error', language),
        description: result.error || t('failedToStart', language),
        duration: 2000
      });
    }
  }, [newGame, language, toast, loadInProgressGame]);

  const handleSubmitGuess = useCallback(async () => {
    const result = await submitGuess(currentGuess);
    if (!result.isValid && result.message) {
      setShake(true);
      setTimeout(() => setShake(false), 600);
      toast({
        title: t(result.message as TranslationKey, language),
        description: result.message === 'wordLength' ? t('wordLength', language, { length: wordLength }) : undefined,
        duration: 2000
      });
    }
  }, [submitGuess, currentGuess, language, toast, wordLength]);

  const handleKeyPress = useCallback((key: string) => {
    if (gameOver && key.toLowerCase() === 'enter') {
      handleStartGame(gameMode);
      return;
    }

    if (!isPlaying || isSubmitting || isLoading) return;

    switch (key.toLowerCase()) {
      case 'enter':
        if (currentGuess.length === wordLength) {
          handleSubmitGuess();
        }
        break;
      case 'backspace':
        if (currentGuess.length > 1) {
          updateCurrentGuess(currentGuess.slice(0, -1));
        }
        break;
      default:
        if (
          key.length === 1 && 
          /^[a-zàâäéèêëîïôöùûüÿçæœ]$/i.test(key) && 
          currentGuess.length < wordLength
        ) {
          updateCurrentGuess(currentGuess + key.toLowerCase());
        }
        break;
    }
  }, [
    gameOver,
    handleStartGame,
    isPlaying,
    isSubmitting,
    currentGuess,
    wordLength,
    handleSubmitGuess,
    updateCurrentGuess,
    gameMode,
    isLoading
  ]);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      handleKeyPress(event.key);
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyPress]);

  useGameEffects({
    gameOver,
    guesses,
    revealedAnswer,
    onShowStats: setShowStatsCard,
    gameMode,
  });

  const handleLanguageChange = (newLang: Language) => {
    setLanguage(newLang);
    saveLanguagePreference(newLang);
    
    const userSavedLayout = loadGameState<KeyboardLayout | null>('keyboardLayout', null);
    if (!userSavedLayout) {
      setKeyboardLayout(newLang === 'fr' ? 'azerty' : 'qwerty');
    }
  };

  const handleHome = () => {
    const isDailyMode = gameMode === 'wordOfTheDay' || gameMode === 'todaysSet';
    if (isPlaying && isDailyMode && !gameOver) {
      saveDailyGameState(gameMode, {
        date: new Date().toDateString(),
        guesses: guesses,
        revealedAnswer: revealedAnswer,
      });
    }
    setShowMenu(true);
    setIsPlaying(false);
    resetGame();
  };

  const handleKeyboardLayoutChange = (layout: KeyboardLayout) => {
    setKeyboardLayout(layout);
    saveGameState('keyboardLayout', layout);
  };

  useEffect(() => {
    const newKeyStates = getKeyboardState(guesses);
    setKeyStates(newKeyStates);
  }, [guesses]);

  const initialBoardStates: LetterState[] = Array(wordLength).fill('empty');
  if (wordLength > 0) {
      initialBoardStates[0] = 'correct';
  }

  return (
    <>
      <AnimatePresence>
        {showMenu && (
          <MainMenu
            selectedLanguage={language}
            onLanguageChange={handleLanguageChange}
            onStartGame={handleStartGame}
            keyboardLayout={keyboardLayout}
            onKeyboardLayoutChange={handleKeyboardLayoutChange}
          />
        )}
      </AnimatePresence>

      <div className="flex flex-col min-h-screen relative z-20">
        {isPlaying && !showMenu && (
          <div className="h-14 sm:h-20">
            <Button
              variant="outline"
              onClick={handleHome}
              className="absolute top-2 sm:top-6 left-1/2 -translate-x-1/2 z-10"
            >
              <Home className="mr-2 h-4 w-4" />
              {t('home', language)}
            </Button>
          </div>
        )}
        
        {isPlaying && (
          <Card className="bg-transparent backdrop-blur-xs shadow-none border-none flex-1 flex items-center justify-center mx-auto max-w-2xl px-4">
            <GameBoard
              guesses={guesses}
              currentGuess={currentGuess}
              wordLength={wordLength}
              showStats={showStatsCard}
              gameOver={gameOver}
              onKeyPress={handleKeyPress}
              onNewGame={() => handleStartGame(gameMode)}
              keyboardLayout={keyboardLayout}
              revealedAnswer={revealedAnswer}
              language={language}
              shake={shake}
              keyStates={keyStates}
              stats={stats}
              isSubmitting={isSubmitting}
              isLoading={isLoading}
              gameMode={gameMode}
              initialStates={initialBoardStates}
            />
          </Card>
        )}
      </div>
    </>
  );
}
--- End of File: components/layout/Game.tsx ---

--- File: components/layout/MainMenu.tsx (Words (approx tokens): 602) ---
'use client';

import { motion } from 'framer-motion';
import { KeyboardLayout } from '@/lib/types/keyboard';
import { Language } from '@/lib/types/i18n';
import { GameMode, GameStats } from '@/lib/types/game';
import { Book, Settings, BarChart, Infinity, Calendar, Sparkles, CheckCircle2 } from 'lucide-react';
import { useState } from 'react';
import { LanguageFlag } from '@/components/ui/LanguageFlag';
import { Button } from "@/components/ui/button";
import { SettingsDialog } from '@/components/ui/SettingsDialog';
import { Title } from '@/components/ui/Title';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { t } from '@/lib/i18n/translations';
import { useGameStats } from '@/hooks/stats/useGameStats';
import { MENU_ANIMATIONS } from '@/lib/utils/animations';
import { DetailedStats } from '@/components/stats/DetailedStats';

interface MainMenuProps {
  selectedLanguage: Language;
  onLanguageChange: (lang: Language) => void;
  onStartGame: (gameMode: GameMode) => void;
  keyboardLayout: KeyboardLayout;
  onKeyboardLayoutChange: (layout: KeyboardLayout) => void;
}

const isDailyCompleted = (stats: GameStats) => {
  if (!stats || stats.lastCompleted === 0) return false;
  const lastCompletionDate = new Date(stats.lastCompleted);
  const today = new Date();
  return lastCompletionDate.toDateString() === today.toDateString() && stats.currentStreak > 0;
};

export function MainMenu({ 
  selectedLanguage, 
  onLanguageChange, 
  onStartGame, 
  keyboardLayout, 
  onKeyboardLayoutChange 
}: MainMenuProps) {
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [showHelp, setShowHelp] = useState(false);
  const [showStats, setShowStats] = useState(false);
  
  const { stats: infiniteStats } = useGameStats({ gameMode: 'infinite' });
  const { stats: wordOfTheDayStats } = useGameStats({ gameMode: 'wordOfTheDay' });
  const { stats: todaysSetStats } = useGameStats({ gameMode: 'todaysSet' });

  const toggleLanguage = () => {
    const newLang = selectedLanguage === 'en' ? 'fr' : 'en';
    onLanguageChange(newLang);
  };

  const handleClearStorage = () => {
    if (typeof window !== 'undefined') {
      window.localStorage.clear();
      setIsSettingsOpen(false);
      window.location.reload();
    }
  };

  const wordOfTheDayCompleted = isDailyCompleted(wordOfTheDayStats);
  const todaysSetCompleted = isDailyCompleted(todaysSetStats);

  return (
    <motion.div
      {...MENU_ANIMATIONS.CONTAINER}
      className="fixed inset-0 flex items-center justify-center z-30"
    >
      <motion.div
        initial={{ scale: 0.95, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        className="px-4 sm:px-8 py-8 max-w-md w-full mx-auto flex flex-col gap-8 justify-center"
      >
        <Title />
        
        <div className="space-y-4">
          <motion.div {...MENU_ANIMATIONS.BUTTON}>
            <Button 
              variant="default" 
              size="lg"
              className="w-full py-7 sm:py-8 text-lg sm:text-xl justify-between group hover:scale-[1.02] transition-transform"
              onClick={() => onStartGame('wordOfTheDay')}
            >
              <span className="flex items-center gap-3">
                <Calendar className="h-6 w-6" />
                <span className="font-semibold">{t('wordOfTheDay', selectedLanguage)}</span>
              </span>
              <span className="flex items-center gap-2">
                {wordOfTheDayCompleted && <CheckCircle2 className="h-5 w-5 text-correct" />}
                <span className="px-3 py-1.5 rounded border-2 border-dashed border-accent">
                  {wordOfTheDayStats.currentStreak}
                </span>
              </span>
            </Button>
          </motion.div>
          <motion.div {...MENU_ANIMATIONS.BUTTON}>
            <Button 
              variant="default" 
              size="lg"
              className="w-full py-7 sm:py-8 text-lg sm:text-xl justify-between group hover:scale-[1.02] transition-transform"
              onClick={() => onStartGame('todaysSet')}
            >
              <span className="flex items-center gap-3">
                <Sparkles className="h-6 w-6" />
                <span className="font-semibold">{t('todaysSet', selectedLanguage)}</span>
              </span>
              <span className="flex items-center gap-2">
                {todaysSetCompleted && <CheckCircle2 className="h-5 w-5 text-correct" />}
                <span className="px-3 py-1.5 rounded border-2 border-dashed border-accent">
                  {todaysSetStats.currentStreak}
                </span>
              </span>
            </Button>
          </motion.div>
          <motion.div {...MENU_ANIMATIONS.BUTTON}>
            <Button 
              variant="default" 
              size="lg"
              className="w-full py-7 sm:py-8 text-lg sm:text-xl justify-start group hover:scale-[1.02] transition-transform"
              onClick={() => onStartGame('infinite')}
            >
              <span className="flex items-center gap-3">
                <Infinity className="h-6 w-6" />
                <span className="font-semibold">{t('infinite', selectedLanguage)}</span>
              </span>
            </Button>
          </motion.div>
        </div>

        <div className="flex justify-center gap-3 sm:gap-4">
          <motion.div {...MENU_ANIMATIONS.BUTTON_EXTRA}>
            <Button
              variant="default"
              size="icon"
              className="h-14 w-14 sm:h-16 sm:w-16 relative group"
              onClick={toggleLanguage}
              aria-label={`Switch to ${selectedLanguage === 'en' ? 'French' : 'English'}`}
            >
              <div className="absolute inset-0 flex items-center justify-center transition-transform group-hover:scale-110">
                <LanguageFlag 
                  language={selectedLanguage} 
                  size={28}
                  className="transition-transform duration-200" 
                />
              </div>
            </Button>
          </motion.div>

          <motion.div {...MENU_ANIMATIONS.BUTTON_EXTRA}>
            <Button
              variant="default"
              size="icon"
              className="h-14 w-14 sm:h-16 sm:w-16 p-2"
              onClick={() => setShowHelp(true)}
            >
              <Book size={24} />
            </Button>
          </motion.div>

          <motion.div {...MENU_ANIMATIONS.BUTTON_EXTRA}>
            <Button
              variant="default"
              size="icon"
              className="h-14 w-14 sm:h-16 sm:w-16 p-2"
              onClick={() => setShowStats(true)}
              aria-label={t('viewStats', selectedLanguage)}
            >
              <BarChart size={24} />
            </Button>
          </motion.div>

          <motion.div {...MENU_ANIMATIONS.BUTTON_EXTRA}>
            <Button
              variant="default"
              size="icon"
              className="h-14 w-14 sm:h-16 sm:w-16 p-2"
              onClick={() => setIsSettingsOpen(true)}
            >
              <Settings size={24} />
            </Button>
          </motion.div>
        </div>
      </motion.div>

      <Dialog open={showHelp} onOpenChange={() => setShowHelp(false)}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle className="text-2xl mb-4">{t('howToPlay', selectedLanguage)}</DialogTitle>
            <DialogDescription className="space-y-4 text-primary leading-relaxed">
              {t('gameRules', selectedLanguage).split('\n').map((rule, index) => (
                <p key={index}>{rule}</p>
              ))}
            </DialogDescription>
          </DialogHeader>
        </DialogContent>
      </Dialog>

      <SettingsDialog
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        onClearStorage={handleClearStorage}
        keyboardLayout={keyboardLayout}
        onKeyboardLayoutChange={onKeyboardLayoutChange}
        language={selectedLanguage}
      />

      <Dialog open={showStats} onOpenChange={setShowStats}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle className="text-2xl mb-4">
              {t('statistics', selectedLanguage)}
            </DialogTitle>
          </DialogHeader>
          <DetailedStats stats={infiniteStats} language={selectedLanguage} />
        </DialogContent>
      </Dialog>
    </motion.div>
  );
}
--- End of File: components/layout/MainMenu.tsx ---

--- File: components/stats/DetailedStats.tsx (Words (approx tokens): 432) ---
import { motion } from 'framer-motion';
import { GameStats } from '@/lib/types/game';
import { Language } from '@/lib/types/i18n';
import { t } from '@/lib/i18n/translations';
import { STATS_ANIMATIONS } from '@/lib/utils/animations';
import { TRIES } from '@/lib/game/constants';

interface DetailedStatsProps {
  stats: GameStats;
  language: Language;
}

interface StatItemProps {
  label: string;
  value: number | string;
  highlight?: boolean;
}

interface GuessDistribution {
  [key: string]: number;
  total: number;
}

const StatItem = ({ label, value, highlight = false }: StatItemProps) => (
  <motion.div 
    className="flex flex-col items-center justify-center p-4 bg-muted/50 rounded-lg"
    initial={STATS_ANIMATIONS.COUNT.initial}
    animate={STATS_ANIMATIONS.COUNT.animate}
    transition={STATS_ANIMATIONS.COUNT.transition}
  >
    <div className={`text-2xl font-bold ${highlight ? 'text-primary' : 'text-primary/80'}`}>
      {value}
    </div>
    <div className="text-sm text-muted-foreground mt-1">{label}</div>
  </motion.div>
);

const GuessDistributionBar = ({ count, total, isHighest }: { count: number; total: number; isHighest: boolean }) => {
  const percentage = total > 0 ? (count / total) * 100 : 0;
  
  return (
    <div className="flex items-center w-full">
      <div 
        className={`h-8 rounded flex items-center transition-all duration-500 ${
          isHighest ? 'bg-muted hover:bg-secondary' : 'bg-muted hover:bg-muted/20'
        }`}
        style={{ width: `${Math.max(percentage, count > 0 ? 10 : 5)}%` }}
      >
        <span className="px-2 text-sm font-medium">{count}</span>
      </div>
    </div>
  );
};

const GuessDistributionChart = ({ distribution, language }: { distribution: GuessDistribution; language: Language }) => {
  const maxCount = Math.max(...Object.values(distribution).filter(val => typeof val === 'number'));
  const maxAttempts = TRIES;
  
  return (
    <div className="space-y-2">
      <h3 className="text-sm font-medium text-muted-foreground mb-2">
        {t('guessDistribution', language)}
      </h3>
      {Array.from({ length: maxAttempts }, (_, i) => i + 1).map(guess => (
        <div key={guess} className="flex items-center gap-2">
          <div className="w-4 text-sm text-muted-foreground">{guess}</div>
          <GuessDistributionBar 
            count={distribution[guess] || 0} 
            total={distribution.total} 
            isHighest={(distribution[guess] || 0) === maxCount && maxCount > 0} 
          />
        </div>
      ))}
    </div>
  );
};

export function DetailedStats({ stats, language }: DetailedStatsProps) {
  const winRate = stats.gamesPlayed > 0 
    ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100)
    : 0;

  const totalGuesses = Object.entries(stats.guessDistribution)
    .reduce((sum, [guesses, count]) => sum + (Number(guesses) * count), 0);
  const averageGuesses = stats.gamesWon > 0 ? (totalGuesses / stats.gamesWon).toFixed(1) : '0';

  const distribution: GuessDistribution = {
    total: stats.gamesWon,
    ...stats.guessDistribution
  };

  for (let i = 1; i <= 6; i++) {
    const key = i.toString();
    if (!(key in distribution)) {
      distribution[key] = 0;
    }
  }

  const lastPlayedDate = new Date(stats.lastPlayed).toLocaleDateString(
    language === 'fr' ? 'fr-FR' : 'en-US',
    { year: 'numeric', month: 'short', day: 'numeric' }
  );

  return (
    <div className="space-y-6 ">
      <div className="grid grid-cols-2 gap-4 ">
        <StatItem 
          label={t('gamesPlayed', language)} 
          value={stats.gamesPlayed} 
        />
        <StatItem 
          label={t('winRate', language)} 
          value={`${winRate}%`}
          highlight={winRate > 50}
        />
        <StatItem 
          label={t('currentStreak', language)} 
          value={stats.currentStreak}
          highlight={stats.currentStreak > 0}
        />
        <StatItem 
          label={t('maxStreak', language)} 
          value={stats.maxStreak}
          highlight={stats.maxStreak > 0}
        />
      </div>

      {stats.gamesPlayed > 0 && (
        <>
          <GuessDistributionChart distribution={distribution} language={language} />
          
          <div className="text-sm text-muted-foreground text-center">
            <p>{t('lastPlayed', language)}: {lastPlayedDate}</p>
            <p className="mt-1">
              {t('avgGuesses', language)}: {averageGuesses}
            </p>
          </div>
        </>
      )}
    </div>
  );
}
--- End of File: components/stats/DetailedStats.tsx ---

--- File: components/ui/LanguageFlag.tsx (Words (approx tokens): 168) ---
import { Language } from '@/lib/types/i18n';
import { cn } from '@/lib/utils';

interface LanguageFlagProps {
  language: Language;
  className?: string;
  size?: number;
}

export function LanguageFlag({ 
  language, 
  className = "",
  size = 32
}: LanguageFlagProps) {
  return (
    <div className={cn('flex items-center justify-center transition-transform', className)}>
      {language === 'fr' ? (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"
             width={size}
             height={size}
             className="rounded-sm shadow-sm"
        >
          <path fill="#fff" d="M10 4H22V28H10z" />
          <path d="M5,4h6V28H5c-2.208,0-4-1.792-4-4V8c0-2.208,1.792-4,4-4Z" fill="#092050" />
          <path d="M27,4h-6V28h6c2.208,0,4-1.792,4-4V8c0-2.208-1.792-4-4-4Z" fill="#be2a2c" />
          <path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Z" opacity=".15" />
        </svg>
      ) : (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"
             width={size}
             height={size}
             className="rounded-sm shadow-sm"
        >
          <rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#071b65" />
          <path d="M5.101,4h-.101c-1.981,0-3.615,1.444-3.933,3.334L26.899,28h.101c1.981,0,3.615-1.444,3.933-3.334L5.101,4Z" fill="#fff" />
          <path d="M22.25,19h-2.5l9.934,7.947c.387-.353,.704-.777,.929-1.257l-8.363-6.691Z" fill="#b92932" />
          <path d="M1.387,6.309l8.363,6.691h2.5L2.316,5.053c-.387,.353-.704,.777-.929,1.257Z" fill="#b92932" />
          <path d="M5,28h.101L30.933,7.334c-.318-1.891-1.952-3.334-3.933-3.334h-.101L1.067,24.666c.318,1.891,1.952,3.334,3.933,3.334Z" fill="#fff" />
          <rect x="13" y="4" width="6" height="24" fill="#fff" />
          <rect x="1" y="13" width="30" height="6" fill="#fff" />
          <rect x="14" y="4" width="4" height="24" fill="#b92932" />
          <rect x="14" y="1" width="4" height="30" transform="translate(32) rotate(90)" fill="#b92932" />
          <path d="M28.222,4.21l-9.222,7.376v1.414h.75l9.943-7.94c-.419-.384-.918-.671-1.471-.85Z" fill="#b92932" />
          <path d="M2.328,26.957c.414,.374,.904,.656,1.447,.832l9.225-7.38v-1.408h-.75L2.328,26.957Z" fill="#b92932" />
          <path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15" />
          <path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2" />
        </svg>
      )}
    </div>
  );
} 
--- End of File: components/ui/LanguageFlag.tsx ---

--- File: components/ui/Loader.tsx (Words (approx tokens): 44) ---
import { motion } from 'framer-motion';

export function Loader() {
  return (
    <motion.div
      style={{
        width: 48,
        height: 48,
        borderRadius: '50%',
        border: '4px solid hsl(var(--primary) / 0.2)',
        borderTopColor: 'hsl(var(--primary))',
      }}
      animate={{ rotate: 360 }}
      transition={{
        loop: Infinity,
        ease: 'linear',
        duration: 1,
      }}
    />
  );
}
--- End of File: components/ui/Loader.tsx ---

--- File: components/ui/SettingsDialog.tsx (Words (approx tokens): 360) ---
'use client';

import { AnimatePresence, motion } from 'framer-motion';
import { Keyboard, Trash2, AlertCircle } from 'lucide-react';
import { KeyboardLayout } from '@/lib/types/keyboard';
import { useState } from 'react';
import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog"
import { Language } from '@/lib/types/i18n';
import { t } from '@/lib/i18n/translations';
import { clearAllGameData } from '@/lib/utils/storage';
import { useToast } from '@/hooks/use-toast';

interface SettingsDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onClearStorage: () => void;
  keyboardLayout: KeyboardLayout;
  onKeyboardLayoutChange: (layout: KeyboardLayout) => void;
  language: Language;
}

export function SettingsDialog({
  isOpen,
  onClose,
  onClearStorage,
  keyboardLayout,
  onKeyboardLayoutChange,
  language
}: SettingsDialogProps) {
  const [showConfirm, setShowConfirm] = useState(false);
  const { toast } = useToast();

  const handleClearClick = () => {
    if (!showConfirm) {
      setShowConfirm(true);
      return;
    }
    
    try {
      clearAllGameData();
      onClearStorage();
      setShowConfirm(false);
      
      toast({
        title: t('clearData', language),
        description: t('dataCleared', language),
        variant: "default"
      });
    } catch {
      toast({
        title: t('error', language),
        description: t('failedToClear', language),
        variant: "destructive"
      });
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Keyboard className="w-6 h-6 text-primary" />
            {t('settings', language)}
          </DialogTitle>
          <DialogDescription>
            {t('configureKeyboard', language)}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6">
          <div className="flex flex-col gap-2">
            <label className="text-sm font-medium">{t('keyboardLayout', language)}</label>
            <p className="text-sm text-primary/50">
              {t('chooseLayout', language)}
            </p>
            <div className="flex gap-2">
              <Button
                onClick={() => onKeyboardLayoutChange('qwerty')}
                variant={keyboardLayout === 'qwerty' ? 'default' : 'outline'}
                className="flex-1"
              >
                <Keyboard className="w-4 h-4 mr-2" />
                QWERTY
              </Button>
              <Button
                onClick={() => onKeyboardLayoutChange('azerty')}
                variant={keyboardLayout === 'azerty' ? 'default' : 'outline'}
                className="flex-1"
              >
                <Keyboard className="w-4 h-4 mr-2" />
                AZERTY
              </Button>
            </div>
          </div>

          <div className="relative h-10">
            <AnimatePresence mode="wait">
              {showConfirm ? (
                <motion.div
                  key="confirm"
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.95 }}
                  transition={{ duration: 0.15, ease: "easeOut" }}
                  className="absolute w-full flex gap-2"
                >
                  <Button
                    onClick={handleClearClick}
                    variant="destructive"
                    className="flex-1"
                  >
                    <AlertCircle className="w-4 h-4 mr-2" />
                    {t('confirmDelete', language)}
                  </Button>
                  <Button
                    onClick={() => setShowConfirm(false)}
                    variant="secondary"
                    className="flex-1"
                  >
                    {t('cancel', language)}
                  </Button>
                </motion.div>
              ) : (
                <motion.div
                  key="clear"
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.95 }}
                  transition={{ duration: 0.15, ease: "easeOut" }}
                  className="absolute w-full"
                >
                  <Button
                    onClick={handleClearClick}
                    variant="destructive"
                    className="w-full"
                  >
                    <Trash2 className="w-4 h-4 mr-2" />
                    {t('clearGameData', language)}
                  </Button>
                </motion.div>
              )}
            </AnimatePresence>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
} 
--- End of File: components/ui/SettingsDialog.tsx ---

--- File: components/ui/Title.tsx (Words (approx tokens): 260) ---
'use client';

import { motion } from 'framer-motion';
import { useEffect, useState } from 'react';
import { Cell } from '@/components/game/Cell'; // Ensure Cell component is imported
import { LetterState } from '@/lib/types/game'; // Import LetterState type

export function Title() {
  const [isRevealed, setIsRevealed] = useState(false);
  const letters = "LEXIC".split("");
  
  // A predefined pattern of states to create a visually appealing mosaic.
  const letterStates: LetterState[] = ['correct', 'absent', 'absent', 'absent', 'absent'];

  // Trigger the reveal animation shortly after the component mounts.
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsRevealed(true);
    }, 300); // A slightly shorter delay feels snappier.
    return () => clearTimeout(timer);
  }, []);

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        // This creates the beautiful cascading reveal effect.
        staggerChildren: 0.15, 
      },
    },
  };

  const itemVariants = {
    hidden: { y: 20, opacity: 0, scale: 0.9 },
    visible: {
      y: 0,
      opacity: 1,
      scale: 1,
      transition: {
        type: 'spring',
        stiffness: 120,
        damping: 12,
      },
    },
  };

  return (
    <div className="relative h-32 flex items-center justify-center">
      <motion.div
        className="relative flex items-center gap-2"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {letters.map((letter, i) => (
          <motion.div
            key={i}
            variants={itemVariants}
            whileHover={{ scale: 1.08, y: -6 }} // Enhanced hover effect
            transition={{ type: 'spring', stiffness: 400, damping: 15 }}
          >
            <Cell
              letter={letter} // Letter is always visible for the flip
              // The state will animate from 'empty' to its designated state in the array.
              state={isRevealed ? letterStates[i] : 'empty'}
              size="large"
              // The individual cell's flip animation is delayed by its position
              delay={i * 0.1} 
            />
          </motion.div>
        ))}
      </motion.div>
    </div>
  );
}
--- End of File: components/ui/Title.tsx ---

--- File: components/ui/button.tsx (Words (approx tokens): 167) ---
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-transparent shadow-sm hover:bg-primary/90 hover:text-primary-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9 p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

--- End of File: components/ui/button.tsx ---

--- File: components/ui/card.tsx (Words (approx tokens): 175) ---
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--- End of File: components/ui/card.tsx ---

--- File: components/ui/dialog.tsx (Words (approx tokens): 276) ---
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

--- End of File: components/ui/dialog.tsx ---

--- File: components/ui/particles-background.tsx (Words (approx tokens): 669) ---
"use client";
import React, { useEffect, useRef } from 'react';

export default function ParticlesBackground() {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    let animationFrameId: number;
    let particles: Particle[] = [];

    const resize = () => {
      if (!canvas) return;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    class Particle {
      x: number;
      y: number;
      z: number;
      baseSize: number;
      opacity: number;
      targetOpacity: number;
      maxOpacity: number;
      vx: number;
      vy: number;
      vz: number;
      color: string;
      luminosity: number;
      type: 'sharp' | 'soft' | 'glow';
      twinkleSpeed: number;
      fadeInSpeed: number;
      life: number;
      maxLife: number;
      isFadingOut: boolean;

      constructor() {
        if (!canvas) throw new Error('Canvas not initialized');
        
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.z = Math.random() * 1000;
        this.baseSize = Math.random() * 0.4 + 0.15;
        this.opacity = 0; // Start at 0 for fade-in
        this.maxOpacity = Math.random() * 0.6 + 0.4; // Increased from 0.4+0.15 to 0.6+0.4
        this.targetOpacity = this.maxOpacity;
        this.vx = (Math.random() - 0.5) * 0.2;
        this.vy = (Math.random() - 0.5) * 0.2;
        this.vz = Math.random() * 0.4 + 0.15;
        
        this.luminosity = Math.random() * 0.7 + 0.3;
        
        const colors = ['#ffffff', '#fefefe', '#f5f5f5', '#e8e8e8', '#f0f0f0'];
        this.color = colors[Math.floor(Math.random() * colors.length)];
        
        const rand = Math.random();
        if (rand < 0.4) {
          this.type = 'sharp';
        } else if (rand < 0.7) {
          this.type = 'soft';
        } else {
          this.type = 'glow';
        }
        
        this.twinkleSpeed = Math.random() * 0.015 + 0.005;
        this.fadeInSpeed = Math.random() * 0.02 + 0.01;
        this.life = 0;
        this.maxLife = Math.random() * 500 + 300;
        this.isFadingOut = false;
      }

      update() {
        if (!canvas) return;
        
        this.x += this.vx;
        this.y += this.vy;
        this.z -= this.vz;
        this.life++;

        // Fade in at the start
        if (this.life < 60 && this.opacity < this.maxOpacity) {
          this.opacity += this.fadeInSpeed;
          if (this.opacity > this.maxOpacity) {
            this.opacity = this.maxOpacity;
          }
        } 
        // Fade out when approaching boundaries or end of life
        else if (this.z < 100 || this.x < 0 || this.x > canvas.width || 
                 this.y < 0 || this.y > canvas.height || this.life > this.maxLife - 60) {
          this.isFadingOut = true;
          this.opacity -= this.fadeInSpeed * 0.8;
          if (this.opacity < 0) this.opacity = 0;
        }
        // Normal twinkling
        else {
          const diff = this.targetOpacity - this.opacity;
          this.opacity += diff * this.twinkleSpeed;
          
          if (Math.abs(diff) < 0.01 && Math.random() < 0.01) {
            this.targetOpacity = Math.random() * 0.3 + (this.maxOpacity * 0.7);
          }
        }

        // Reset particle when fully faded out
        if (this.isFadingOut && this.opacity <= 0) {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.z = 1000;
          this.opacity = 0;
          this.targetOpacity = this.maxOpacity;
          this.life = 0;
          this.isFadingOut = false;
        }
      }

      draw() {
        if (!ctx) return;
        
        const scale = 1000 / (1000 + this.z);
        const size = this.baseSize * scale * 8;
        const finalOpacity = this.opacity * scale; // Removed the * 0.8 that was dimming

        if (size < 0.05 || finalOpacity < 0.005) return;

        ctx.save();
        ctx.globalAlpha = finalOpacity;

        if (this.type === 'sharp') {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
          ctx.fill();
        } else if (this.type === 'soft') {
          const blur = scale < 0.5 ? 0.5 : scale * 1.5;
          ctx.filter = `blur(${blur}px)`;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, size * 1.2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          const blur = Math.max(1, scale * 3);
          ctx.filter = `blur(${blur}px)`;
          
          const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size * 2.5);
          gradient.addColorStop(0, this.color);
          gradient.addColorStop(0.4, this.color + 'aa');
          gradient.addColorStop(1, this.color + '00');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, size * 2.5, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }
    }

    const init = () => {
      resize();
      particles = [];
      for (let i = 0; i < 120; i++) {
        particles.push(new Particle());
      }
    };

    const animate = () => {
      if (!ctx || !canvas) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      particles.sort((a, b) => b.z - a.z);

      particles.forEach(particle => {
        particle.update();
        particle.draw();
      });

      animationFrameId = requestAnimationFrame(animate);
    };

    init();
    animate();

    window.addEventListener('resize', resize);

    return () => {
      window.removeEventListener('resize', resize);
      cancelAnimationFrame(animationFrameId);
    };
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className="fixed inset-0 w-full h-full pointer-events-none"
      style={{ zIndex: 0 }}
    />
  );
}
--- End of File: components/ui/particles-background.tsx ---

--- File: components/ui/toast.tsx (Words (approx tokens): 342) ---
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed bottom-0 z-[100] flex max-h-screen flex-col-reverse p-4 sm:flex-col",
      "left-[50%] translate-x-[-50%]",
      "w-fit min-w-[150px] max-w-[350px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-bottom-full data-[state=open]:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(
        toastVariants({ variant }),
        "w-fit",
        className
      )}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

--- End of File: components/ui/toast.tsx ---

--- File: components/ui/toaster.tsx (Words (approx tokens): 69) ---
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

--- End of File: components/ui/toaster.tsx ---

--- File: hooks/use-toast.ts (Words (approx tokens): 450) ---
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 3000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id"> & {
  duration?: number;
}

function toast({ duration = TOAST_REMOVE_DELAY, ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

--- End of File: hooks/use-toast.ts ---

--- File: hooks/useKeyboardControls.ts (Words (approx tokens): 150) ---
import { useEffect, useCallback } from 'react';
import { KeyboardLayout } from '@/lib/types/keyboard';

interface UseKeyboardControlsProps {
  isPlaying: boolean;
  gameOver: boolean;
  currentGuess: string;
  wordLength: number;
  onSubmit: () => void;
  onUpdateGuess: (guess: string) => void;
  keyboardLayout: KeyboardLayout;
  isSubmitting: boolean;
}

export function useKeyboardControls({
  isPlaying,
  gameOver,
  currentGuess,
  wordLength,
  onSubmit,
  onUpdateGuess,
  keyboardLayout,
  isSubmitting
}: UseKeyboardControlsProps) {
  const handleKeyPress = useCallback((key: string) => {
    if (!isPlaying || gameOver || isSubmitting) return;

    const normalizedKey = key.toLowerCase();

    if (key === 'Enter') {
      onSubmit();
    } else if (key === 'Backspace') {
      onUpdateGuess(currentGuess.slice(0, -1));
    } else if (
      /^[a-zA-Z]$/.test(key) && 
      currentGuess.length < wordLength
    ) {
      onUpdateGuess(currentGuess + normalizedKey);
    }

    if (keyboardLayout === 'azerty') {
      // Handle AZERTY-specific mappings if needed
    }
  }, [gameOver, currentGuess, wordLength, onSubmit, onUpdateGuess, keyboardLayout, isSubmitting]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!isPlaying) return;
      handleKeyPress(e.key);
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isPlaying, handleKeyPress]);

  return { handleKeyPress };
} 
--- End of File: hooks/useKeyboardControls.ts ---

--- File: hooks/game/useGameEffects.ts (Words (approx tokens): 210) ---
import { useEffect, useRef } from 'react';
import { useGameStats } from '../stats/useGameStats';
import { GuessResult, GameMode } from '@/lib/types/game';
import { saveGameState, clearDailyGameState } from '@/lib/utils/storage';

interface UseGameEffectsProps {
  gameOver: boolean;
  guesses: GuessResult[];
  revealedAnswer: string | null;
  onShowStats: (show: boolean) => void;
  gameMode: GameMode;
}

export function useGameEffects({
  gameOver,
  guesses,
  revealedAnswer,
  onShowStats,
  gameMode
}: UseGameEffectsProps) {
  const { updateGameResult } = useGameStats({ gameMode });
  const hasUpdatedStats = useRef(false);

  // Handle game completion
  useEffect(() => {
    if (gameOver && revealedAnswer && !hasUpdatedStats.current) {
      const isWon = guesses.length > 0 && guesses[guesses.length - 1].isCorrect;
      
      // Update game statistics only once
      hasUpdatedStats.current = true;
      updateGameResult({
        won: isWon,
        numGuesses: guesses.length,
        word: revealedAnswer,
        timestamp: Date.now()
      });

      // Clear the in-progress game state upon completion for daily modes
      if (gameMode === 'wordOfTheDay' || gameMode === 'todaysSet') {
        clearDailyGameState(gameMode);
      }

      // Show stats card with delay
      setTimeout(() => {
        onShowStats(true);
      }, 1500);
    }

    // Reset the flag when the game is not over
    if (!gameOver) {
      hasUpdatedStats.current = false;
    }
  }, [gameOver, guesses, revealedAnswer, updateGameResult, onShowStats, gameMode]);

  // Save current game state
  useEffect(() => {
    if (guesses.length > 0) {
      saveGameState('currentGame', {
        guesses: guesses.map(g => ({
          word: g.word,
          isCorrect: g.isCorrect
        })), // Store minimal guess info
        answer: revealedAnswer,
        timestamp: Date.now()
      });
    }
  }, [guesses, revealedAnswer]);
}
--- End of File: hooks/game/useGameEffects.ts ---

--- File: hooks/game/useGameInput.ts (Words (approx tokens): 186) ---
import { useCallback, useEffect } from 'react';
import { KeyboardLayout } from '@/lib/types/keyboard';

interface UseGameInputProps {
  isPlaying: boolean;
  gameOver: boolean;
  currentGuess: string;
  wordLength: number;
  onSubmit: () => void;
  onUpdateGuess: (guess: string) => void;
  keyboardLayout: KeyboardLayout;
  isSubmitting: boolean;
}

export function useGameInput({
  isPlaying,
  gameOver,
  currentGuess,
  wordLength,
  onSubmit,
  onUpdateGuess,
  keyboardLayout,
  isSubmitting
}: UseGameInputProps) {
  const handleKeyPress = useCallback((key: string) => {
    if (!isPlaying) return;
    
    if (gameOver && key.toLowerCase() === 'enter') {
      onSubmit();
      return;
    }

    if (gameOver || isSubmitting) return;

    switch (key.toLowerCase()) {
      case 'enter':
        if (currentGuess.length === wordLength) {
          onSubmit();
        }
        break;
      case 'backspace':
        onUpdateGuess(currentGuess.slice(0, -1));
        break;
      default:
        // Updated regex to support French characters
        if (
          key.length === 1 && 
          /^[a-zàâäéèêëîïôöùûüÿçæœ]$/i.test(key) && 
          currentGuess.length < wordLength
        ) {
          onUpdateGuess(currentGuess + key.toLowerCase());
        }
        break;
    }
  }, [
    isPlaying,
    gameOver,
    currentGuess,
    wordLength,
    onSubmit,
    onUpdateGuess,
    isSubmitting
  ]);

  // Physical keyboard handler
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (!isPlaying || gameOver) return;

      const key = event.key;
      if (key === 'Enter' || key === 'Backspace' || /^[a-zA-Z]$/.test(key)) {
        event.preventDefault();
        handleKeyPress(key);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isPlaying, gameOver, handleKeyPress]);

  return { handleKeyPress };
}

--- End of File: hooks/game/useGameInput.ts ---

--- File: hooks/game/useGameLogic.ts (Words (approx tokens): 522) ---
import { useState, useCallback} from 'react';
import { GameState, GuessResult, GameMode } from '@/lib/types/game';
import { Language } from '@/lib/types/i18n';

interface GameLogicState {
  wordLength: number;
  guesses: GuessResult[];
  currentGuess: string;
  gameOver: boolean;
  isSubmitting: boolean;
  revealedAnswer: string | null;
  isLoading: boolean;
  firstLetter: string;
}

interface UseGameLogicProps {
  language: Language;
  maxAttempts?: number;
}

interface SubmitGuessResult {
  isValid: boolean;
  message?: string;
}

export function useGameLogic({ language, maxAttempts = 6 }: UseGameLogicProps) {
  const [state, setState] = useState<GameLogicState>({
    wordLength: 0,
    guesses: [],
    currentGuess: '',
    gameOver: false,
    isSubmitting: false,
    revealedAnswer: null,
    isLoading: false,
    firstLetter: '',
  });

  const resetGame = useCallback(() => {
    setState({
      wordLength: 0,
      guesses: [],
      currentGuess: '',
      gameOver: false,
      isSubmitting: false,
      revealedAnswer: null,
      isLoading: false,
      firstLetter: '',
    });
  }, []);

  const newGame = useCallback(async (options: { gameMode: GameMode }) => {
    setState(prev => ({ ...prev, isLoading: true }));
    try {
      const response = await fetch('/api/game', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action: 'new', language, gameMode: options.gameMode })
      });

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to start game');
      }

      setState(prev => ({
        ...prev,
        wordLength: data.length,
        guesses: [],
        currentGuess: data.firstLetter || '',
        gameOver: false,
        revealedAnswer: null,
        firstLetter: data.firstLetter || '',
      }));

      return { success: true };
    } catch (error) {
      console.error('Failed to start new game:', error);
      return { 
        success: false, 
        error: 'failedToStart'
      };
    } finally {
      setState(prev => ({ ...prev, isLoading: false }));
    }
  }, [language]);

  const submitGuess = useCallback(async (guess: string): Promise<SubmitGuessResult> => {
    if (state.isSubmitting || state.gameOver) {
      return { isValid: false };
    }

    setState(prev => ({ ...prev, isSubmitting: true }));

    const validCharPattern = language === 'fr' 
      ? /^[a-zàâäéèêëîïôöùûüÿçæœ]+$/i
      : /^[a-z]+$/i;

    if (!validCharPattern.test(guess)) {
      setState(prev => ({...prev, isSubmitting: false}));
      return {
        isValid: false,
        message: 'invalidCharacters'
      };
    }

    try {
      const response = await fetch('/api/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          guess,
          language,
          guessCount: state.guesses.length
        })
      });

      const data = await response.json();

      if (!data.isValid) {
        return { 
          isValid: false, 
          message: data.message 
        };
      }

      const newGuess: GuessResult = {
        word: guess,
        letterStates: data.letterStates,
        isCorrect: data.isCorrect
      };

      setState(prev => {
        const newGuesses = [...prev.guesses, newGuess];
        const gameOver = data.isCorrect || newGuesses.length >= maxAttempts;

        return {
          ...prev,
          guesses: newGuesses,
          currentGuess: gameOver ? '' : prev.firstLetter,
          gameOver: gameOver,
          isSubmitting: false,
          revealedAnswer: gameOver ? data.answer : null
        };
      });

      return { isValid: true };
    } catch (error) {
      console.error('Error submitting guess:', error);
      return { 
        isValid: false, 
        message: 'error'
      };
    } finally {
      setState(prev => ({ ...prev, isSubmitting: false }));
    }
  }, [state.isSubmitting, state.gameOver, state.guesses.length, language, maxAttempts]);
  
  const loadInProgressGame = useCallback((savedState: { guesses: GuessResult[], revealedAnswer: string | null }) => {
    const { guesses, revealedAnswer } = savedState;
    const lastGuess = guesses.length > 0 ? guesses[guesses.length - 1] : null;
    const isGameOver = !!revealedAnswer || (lastGuess?.isCorrect ?? false) || guesses.length >= maxAttempts;

    setState(prev => ({
      ...prev,
      guesses: guesses,
      currentGuess: isGameOver ? '' : prev.firstLetter,
      gameOver: isGameOver,
      revealedAnswer: revealedAnswer,
    }));
  }, [maxAttempts]);

  return {
    ...state,
    newGame,
    submitGuess,
    updateCurrentGuess: useCallback((guess: string) => {
      if (!state.gameOver) {
        setState(prev => ({ ...prev, currentGuess: guess }));
      }
    }, [state.gameOver]),
    resetGame,
    loadInProgressGame,
    getGameState: useCallback((): GameState => {
      if (!state.gameOver) return 'playing';
      return state.guesses[state.guesses.length - 1]?.isCorrect ? 'won' : 'lost';
    }, [state.gameOver, state.guesses])
  };
}
--- End of File: hooks/game/useGameLogic.ts ---

--- File: hooks/stats/useGameStats.ts (Words (approx tokens): 223) ---
import { useState, useEffect, useCallback } from 'react';
import { GameStats, GameResult, GameMode } from '@/lib/types/game';
import { statsManager } from '@/lib/stats/statsManager';

interface UseGameStatsProps {
  gameMode: GameMode;
}

interface UseGameStatsReturn {
  stats: GameStats;
  isUpdating: boolean;
  isLoading: boolean;
  error: Error | null;
  updateGameResult: (result: GameResult) => Promise<void>;
  resetStats: () => void;
}

export function useGameStats({ gameMode }: UseGameStatsProps): UseGameStatsReturn {
  const [stats, setStats] = useState<GameStats>(statsManager.getStats(gameMode));
  const [isUpdating, setIsUpdating] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    setIsLoading(true);
    try {
      const initialStats = statsManager.getStats(gameMode);
      setStats(initialStats);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to load stats'));
    } finally {
      setIsLoading(false);
    }
  }, [gameMode]);

  useEffect(() => {
    const handleStatsChange = (newStats: GameStats, updatedGameMode: GameMode) => {
      if (gameMode === updatedGameMode) {
        setStats(newStats);
      }
    };
    const unsubscribe = statsManager.addListener(handleStatsChange);
    return unsubscribe;
  }, [gameMode]);

  const updateGameResult = useCallback(async (result: GameResult) => {
    setIsUpdating(true);
    try {
      statsManager.updateGameResult(result, gameMode);
    } catch (error) {
      console.error('Error updating game result:', error);
      setError(error instanceof Error ? error : new Error('Failed to update stats'));
    } finally {
      setIsUpdating(false);
    }
  }, [gameMode]);

  const resetStats = useCallback(() => {
    try {
      statsManager.resetStats(gameMode);
    } catch (error) {
      console.error('Error resetting stats:', error);
      setError(error instanceof Error ? error : new Error('Failed to reset stats'));
    }
  }, [gameMode]);

  return {
    stats,
    isUpdating,
    isLoading,
    error,
    updateGameResult,
    resetStats
  };
}
--- End of File: hooks/stats/useGameStats.ts ---

--- File: lib/utils.ts (Words (approx tokens): 28) ---
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

// Keep this for shadcn/ui components
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
--- End of File: lib/utils.ts ---

--- File: lib/game/constants.ts (Words (approx tokens): 20) ---
export const MIN_WORD_LENGTH = 4;
export const MAX_WORD_LENGTH = 9;
export const TRIES = 6;
export const MAX_RECENT_GAMES = 10; 
--- End of File: lib/game/constants.ts ---

--- File: lib/game/validation.ts (Words (approx tokens): 243) ---
import { TranslationKey } from '@/lib/types/i18n';
import { Language } from '@/lib/types/i18n';
import { isValidWord } from '@/lib/game/words';
import { LetterState } from '../types/game';
import { MIN_WORD_LENGTH, MAX_WORD_LENGTH } from './constants';

export interface ValidationResult {
  isValid: boolean;
  message?: TranslationKey;
}

export function validateGuess(
  word: string, 
  expectedLength: number, 
  language: Language
): ValidationResult {
  const normalizedWord = word.toLowerCase();

  // Check length
  if (normalizedWord.length !== expectedLength) {
    return { 
      isValid: false, 
      message: 'wordLength'
    };
  }
  
  // Check characters
  if (!/^[a-zÀ-ÿ]+$/i.test(normalizedWord)) {
    return { 
      isValid: false, 
      message: 'invalidCharacters'
    };
  }
  
  // Check if word exists in dictionary
  if (!isValidWord(normalizedWord, language)) {
    return { 
      isValid: false, 
      message: 'notInWordList'
    };
  }
  
  return { isValid: true };
}

// Helper function to remove accents for comparison
export function normalizeWord(word: string): string {
  return word.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
}

// Validate word length range
export function isValidWordLength(length: number): boolean {
  return length >= MIN_WORD_LENGTH && length <= MAX_WORD_LENGTH;
}

export function getLetterStates(guess: string, answer: string): LetterState[] {
  const states: LetterState[] = Array(guess.length).fill('absent');
  
  // Normalize both strings for comparison
  const normalizedAnswer = normalizeWord(answer.toLowerCase()).split('');
  const normalizedGuess = normalizeWord(guess.toLowerCase()).split('');
  
  // First pass: mark correct letters
  normalizedGuess.forEach((letter, i) => {
    if (letter === normalizedAnswer[i]) {
      states[i] = 'correct';
      normalizedAnswer[i] = '#'; // Mark as used
    }
  });

  // Second pass: mark present letters
  normalizedGuess.forEach((letter, i) => {
    if (states[i] !== 'correct') {
      const answerIndex = normalizedAnswer.indexOf(letter);
      if (answerIndex !== -1) {
        states[i] = 'present';
        normalizedAnswer[answerIndex] = '#'; // Mark as used
      }
    }
  });

  return states;
}
--- End of File: lib/game/validation.ts ---

--- File: lib/game/words.ts (Words (approx tokens): 333) ---
import { Language } from '@/lib/types/i18n';
import { MIN_WORD_LENGTH, MAX_WORD_LENGTH } from './constants';
import { LetterState } from '@/lib/types/game';
import englishWords from 'an-array-of-english-words';
import frenchWords from 'an-array-of-french-words';

// Initialize word lists with type assertions
const VALID_WORDS: Record<Language, string[]> = {
  en: (englishWords as string[]).filter((word: string) => 
    word.length >= MIN_WORD_LENGTH && 
    word.length <= MAX_WORD_LENGTH &&
    /^[a-zÀ-ÿ]+$/i.test(word)
  ).map((word: string) => word.toLowerCase()),
  
  fr: (frenchWords as string[]).filter((word: string) => 
    word.length >= MIN_WORD_LENGTH && 
    word.length <= MAX_WORD_LENGTH &&
    /^[a-zÀ-ÿ]+$/i.test(word)
  ).map((word: string) => word.toLowerCase())
};

// Pre-compute words by length for faster lookup
export const WORDS_BY_LENGTH: Record<Language, Record<number, string[]>> = {
  en: {},
  fr: {}
};

// Initialize word length maps
Object.entries(VALID_WORDS).forEach(([lang, words]) => {
  words.forEach(word => {
    const length = word.length;
    if (!WORDS_BY_LENGTH[lang as Language][length]) {
      WORDS_BY_LENGTH[lang as Language][length] = [];
    }
    WORDS_BY_LENGTH[lang as Language][length].push(word);
  });
});

export function getRandomWord(language: Language = 'en'): string {
  const length = Math.floor(Math.random() * (MAX_WORD_LENGTH - MIN_WORD_LENGTH + 1)) + MIN_WORD_LENGTH;
  const wordsOfLength = WORDS_BY_LENGTH[language][length];
  
  if (!wordsOfLength || wordsOfLength.length === 0) {
    throw new Error(`No ${length}-letter words found for language: ${language}`);
  }
  
  return wordsOfLength[Math.floor(Math.random() * wordsOfLength.length)];
}

export function getWordOfTheDay(language: Language = 'en'): string {
  const wordList = Object.values(WORDS_BY_LENGTH[language]).flat();

  if (!wordList || wordList.length === 0) {
    console.error(`No words found for language: ${language} to determine word of the day.`);
    return getRandomWord(language);
  }

  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = (now.getTime() - start.getTime()) + ((start.getTimezoneOffset() - now.getTimezoneOffset()) * 60 * 1000);
  const dayOfYear = Math.floor(diff / (1000 * 60 * 60 * 24));

  const index = dayOfYear % wordList.length;
  return wordList[index];
}

// Add accent normalization helper
export function normalizeWord(word: string): string {
  return word.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
}

// Update word validation to handle accents better
export function isValidWord(word: string, language: Language): boolean {
  const normalizedInput = normalizeWord(word);
  return VALID_WORDS[language].some(dictWord => 
    normalizeWord(dictWord) === normalizedInput
  );
}

const letterStateStyles = {
    correct: 'bg-correct text-foreground border-primary',
    present: 'bg-present text-foreground border-primary',
    absent: 'bg-transparent text-foreground border-primary',
    empty: 'bg-transparent border-primary/30'
  } as const;
  
  export function getLetterStateClass(state: LetterState): string {
    return letterStateStyles[state];
  }
--- End of File: lib/game/words.ts ---

--- File: lib/i18n/translations.ts (Words (approx tokens): 586) ---
import { Language, TranslationKey } from '@/lib/types/i18n';

export const translations: Record<Language, Record<TranslationKey, string>> = {
  en: {
    startGame: 'Play',
    settings: 'Settings',
    howToPlay: 'How to Play',
    keyboardLayout: 'Keyboard Layout',
    chooseLayout: 'Choose your preferred keyboard layout for typing.',
    clearData: 'Clear Data',
    confirmClear: 'Are you sure? This will clear all game data.',
    cancelClear: 'Cancel',
    gameRules: [
      'Guess the word.',
      'Each guess must be a valid word.',
      'After each guess, the color of the tiles will change:',
      '🟩 Green: Letter is correct and in right position',
      '🟨 Yellow: Letter is in the word but wrong position',
      '⬜ Empty: Letter is not in the word'
    ].join('\n'),
    newGame: 'New Game',
    gamePlayed: 'Game Played',
    configureKeyboard: 'Configure your keyboard layout and manage game data.',
    wordLength: 'Word must be {length} letters',
    invalidWord: 'Invalid word',
    notInList: 'Not in word list',
    gameOver: 'Game Over',
    youWon: 'You won!',
    answer: 'The word was: {word}',
    winPercentage: 'Win %',
    streak: 'Current Streak',
    maxStreak: 'Max Streak',
    searchDefinition: 'Search definition',
    error: 'Error',
    noActiveGame: 'No active game',
    invalidCharacters: 'Invalid characters',
    notInWordList: 'Not in word list',
    failedToStart: 'Failed to start game',
    home: 'Home',
    viewStats: 'View Statistics',
    gamesPlayed: 'Played',
    winRate: 'Win Rate',
    currentStreak: 'Current Streak',
    bestStreak: 'Best Streak',
    dataCleared: 'Game data cleared successfully',
    failedToClear: 'Failed to clear game data',
    statistics: 'Statistics',
    avgGuesses: 'Avg. Guesses',
    gamesWon: 'Games Won',
    guessDistribution: 'Guess Distribution',
    lastPlayed: 'Last Played',
    confirmDelete: 'Are you sure? ',  
    cancel: 'Cancel',
    clearGameData: 'Clear Game Data',
    pressEnterNewGame: 'Press Enter for New Game',
    infinite: 'Infinite',
    wordOfTheDay: 'Word of the Day',
    todaysSet: "Today's Set",
    loading: 'Loading...',
  },
  fr: {
    startGame: 'Jouer',
    settings: 'Paramètres',
    howToPlay: 'Comment Jouer',
    keyboardLayout: 'Disposition du Clavier',
    chooseLayout: 'Choisissez votre disposition de clavier préférée.',
    clearData: 'Effacer les Données',
    confirmClear: 'Êtes-vous sûr ? Cela effacera toutes les données du jeu.',
    cancelClear: 'Annuler',
    gameRules: [
      'Devinez le mot.',
      'Chaque essai doit être un mot valide.',
      'Après chaque essai, la couleur des tuiles changera :',
      '🟩 Vert : Lettre correcte et bien placée',
      '🟨 Jaune : Lettre dans le mot mais mal placée',
      '⬜ Vide : Lettre absente du mot'
    ].join('\n'),
    newGame: 'Nouvelle Partie',
    gamePlayed: 'Parties Jouées',
    configureKeyboard: 'Configurez votre clavier et gérez les données du jeu.',
    wordLength: 'Le mot doit faire {length} lettres',
    invalidWord: 'Mot invalide',
    notInList: 'Mot non trouvé',
    gameOver: 'Partie Terminée',
    youWon: 'Vous avez gagné !',
    answer: 'Le mot était : {word}',
    winPercentage: 'Victoires %',
    streak: 'Série Actuelle',
    maxStreak: 'Série Max',
    searchDefinition: 'Chercher la définition',
    error: 'Erreur',
    noActiveGame: 'Aucune partie active',
    invalidCharacters: 'Caractères invalides',
    notInWordList: 'Mot non trouvé',
    failedToStart: 'Échec du démarrage',
    home: 'Accueil',
    viewStats: 'Voir les Statistiques',
    gamesPlayed: 'Parties',
    winRate: 'Taux de Réussite',
    currentStreak: 'Série Actuelle',
    bestStreak: 'Meilleure Série',
    dataCleared: 'Données du jeu effacées avec succès',
    failedToClear: 'Échec de l\'effacement des données',
    statistics: 'Statistiques',
    avgGuesses: 'Moy. essais',
    gamesWon: 'Parties Gagnées',
    guessDistribution: 'Distribution des essais',
    lastPlayed: 'Dernière partie',
    confirmDelete: 'Êtes-vous sûr ?',
    cancel: 'Annuler',
    clearGameData: 'Effacer les Données du Jeu',
    pressEnterNewGame: 'Appuyez sur Entrée pour une nouvelle partie',
    infinite: 'Infini',
    wordOfTheDay: 'Mot du Jour',
    todaysSet: 'Série du Jour',
    loading: 'Chargement...',
  }
};

export function t(key: TranslationKey, lang: Language, params?: Record<string, string | number>): string {
  const text = translations[lang][key];
  if (!text) {
    console.warn(`Translation key "${key}" not found for language "${lang}".`);
    return translations['en'][key] || key;
  }
  if (!params) return text;
  
  return Object.entries(params).reduce(
    (str, [key, value]) => str.replace(`{${key}}`, value.toString()),
    text
  );
}

// Type for translation parameters
export type TranslationParams = Record<string, string | number>;

// Add validation for translation keys
export function validateTranslationKey(key: string): key is TranslationKey {
  return key in translations.en;
}

// Add missing translation detection
export function getMissingTranslations(): TranslationKey[] {
  const enKeys = Object.keys(translations.en);
  const frKeys = Object.keys(translations.fr);
  return enKeys.filter(key => !frKeys.includes(key)) as TranslationKey[];
}
--- End of File: lib/i18n/translations.ts ---

--- File: lib/stats/statsManager.ts (Words (approx tokens): 531) ---
import type { GameStats, GameResult, GameMode } from '@/lib/types/game';
import { MAX_RECENT_GAMES } from '@/lib/game/constants';

const createInitialStats = (): GameStats => ({
  gamesPlayed: 0,
  gamesWon: 0,
  currentStreak: 0,
  maxStreak: 0,
  lastPlayed: Date.now(),
  lastCompleted: 0,
  guessDistribution: {},
  recentGames: []
});

type AllGameStats = Record<GameMode, GameStats>;

export class StatsManager {
  private readonly STORAGE_KEY = 'lexic-stats';
  private stats: AllGameStats;
  private readonly listeners: Set<(stats: GameStats, gameMode: GameMode) => void>;

  constructor() {
    this.stats = this.loadStats();
    this.listeners = new Set();
  }

  private loadStats(): AllGameStats {
    const defaultStats: AllGameStats = {
      infinite: createInitialStats(),
      wordOfTheDay: createInitialStats(),
      todaysSet: createInitialStats(),
    };

    if (typeof window === 'undefined') return defaultStats;

    try {
      const saved = localStorage.getItem(this.STORAGE_KEY);
      if (!saved) return defaultStats;

      const parsed = JSON.parse(saved);
      
      return {
        infinite: this.validateStats(parsed.infinite || {}),
        wordOfTheDay: this.validateStats(parsed.wordOfTheDay || {}),
        todaysSet: this.validateStats(parsed.todaysSet || {}),
      };
    } catch (error) {
      console.error('Failed to load stats:', error);
      return defaultStats;
    }
  }

  private validateStats(stats: Partial<GameStats>): GameStats {
    const now = Date.now();
    return {
      gamesPlayed: Math.max(0, Number(stats.gamesPlayed) || 0),
      gamesWon: Math.max(0, Number(stats.gamesWon) || 0),
      currentStreak: Math.max(0, Number(stats.currentStreak) || 0),
      maxStreak: Math.max(0, Number(stats.maxStreak) || 0),
      lastPlayed: Number(stats.lastPlayed) || now,
      lastCompleted: Number(stats.lastCompleted) || now,
      guessDistribution: { ...stats.guessDistribution },
      recentGames: Array.isArray(stats.recentGames) 
        ? stats.recentGames.slice(0, MAX_RECENT_GAMES)
        : []
    };
  }

  private saveStats(): void {
    if (typeof window === 'undefined') return;

    try {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.stats));
    } catch (error) {
      console.error('Failed to save stats:', error);
    }
  }

  private notifyListeners(gameMode: GameMode): void {
    this.listeners.forEach(listener => listener(this.getStats(gameMode), gameMode));
  }

  public addListener(listener: (stats: GameStats, gameMode: GameMode) => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  public getStats(gameMode: GameMode): GameStats {
    return { ...(this.stats[gameMode] || createInitialStats()) };
  }

  public updateGameResult(result: GameResult, gameMode: GameMode): GameStats {
    const now = Date.now();
    const currentStats = this.getStats(gameMode);
    
    // Streak logic depends on the game mode. Daily modes should check against the previous day.
    const isDailyMode = gameMode === 'wordOfTheDay' || gameMode === 'todaysSet';
    const lastCompletionDate = new Date(currentStats.lastCompleted);
    const today = new Date(now);
    const yesterday = new Date(now);
    yesterday.setDate(today.getDate() - 1);

    const isSameDayCompletion = lastCompletionDate.toDateString() === today.toDateString();
    // For daily modes, don't update streak if another game was won today
    if (isDailyMode && result.won && isSameDayCompletion) {
       return currentStats;
    }

    const isContinuedStreak = lastCompletionDate.toDateString() === yesterday.toDateString();
    
    let newCurrentStreak = currentStats.currentStreak;
    if (result.won) {
        if (isDailyMode) {
            newCurrentStreak = isContinuedStreak ? newCurrentStreak + 1 : 1;
        } else { // infinite mode
            newCurrentStreak += 1;
        }
    } else {
        newCurrentStreak = 0;
    }

    const newStats: GameStats = {
      ...currentStats,
      gamesPlayed: currentStats.gamesPlayed + 1,
      gamesWon: result.won ? currentStats.gamesWon + 1 : currentStats.gamesWon,
      currentStreak: newCurrentStreak,
      lastPlayed: now,
      lastCompleted: result.won ? now : currentStats.lastCompleted,
      guessDistribution: result.won ? {
        ...currentStats.guessDistribution,
        [result.numGuesses]: (currentStats.guessDistribution[result.numGuesses] || 0) + 1
      } : currentStats.guessDistribution,
      recentGames: [
        {
          word: result.word,
          guesses: result.numGuesses,
          won: result.won,
          timestamp: result.timestamp
        },
        ...currentStats.recentGames
      ].slice(0, MAX_RECENT_GAMES)
    };

    newStats.maxStreak = Math.max(currentStats.maxStreak, newStats.currentStreak);

    this.stats[gameMode] = newStats;
    this.saveStats();
    this.notifyListeners(gameMode);
    return this.getStats(gameMode);
  }

  public resetStats(gameMode: GameMode): GameStats {
    this.stats[gameMode] = createInitialStats();
    this.saveStats();
    this.notifyListeners(gameMode);
    return this.getStats(gameMode);
  }
  
  public clearAllGameData(): void {
    if (typeof window === 'undefined') return;
    
    try {
      localStorage.removeItem(this.STORAGE_KEY);
      this.stats = this.loadStats(); // Reloads defaults
      // Optionally notify listeners for all modes that stats have been cleared
    } catch (error) {
      console.error('Failed to clear game data:', error);
      throw new Error('Failed to clear game data');
    }
  }
}

// Export singleton instance
export const statsManager = new StatsManager();
--- End of File: lib/stats/statsManager.ts ---

--- File: lib/types/game.ts (Words (approx tokens): 102) ---
export type GameMode = 'infinite' | 'wordOfTheDay' | 'todaysSet';

export type GameState = 'playing' | 'won' | 'lost';

export interface GameStats {
  gamesPlayed: number;
  gamesWon: number;
  currentStreak: number;
  maxStreak: number;
  lastPlayed: number;
  lastCompleted: number;
  guessDistribution: Record<number, number>;
  recentGames: {
    word: string;
    guesses: number;
    won: boolean;
    timestamp: number;
  }[];
}

export interface GameResult {
  won: boolean;
  numGuesses: number;
  word: string;
  timestamp: number;
}

export type LetterState = "correct" | "present" | "absent" | "empty";

export interface GuessResult {
  word: string;
  letterStates: LetterState[];
  isCorrect: boolean;
} 

export interface StatsError {
    code: string;
    message: string;
  }
  
export interface StatsValidation {
    isValid: boolean;
    errors?: StatsError[];
  }
--- End of File: lib/types/game.ts ---

--- File: lib/types/i18n.ts (Words (approx tokens): 115) ---
export type Language = 'en' | 'fr';
export type TranslationKey = 
  | 'startGame'
  | 'settings'
  | 'howToPlay'
  | 'keyboardLayout'
  | 'chooseLayout'
  | 'clearData'
  | 'confirmClear'
  | 'cancelClear'
  | 'gameRules'
  | 'newGame'
  | 'gamePlayed'
  | 'configureKeyboard'
  | 'wordLength'
  | 'invalidWord'
  | 'notInList'
  | 'gameOver'
  | 'youWon'
  | 'answer'
  | 'winPercentage'
  | 'streak'
  | 'maxStreak'
  | 'searchDefinition'
  | 'error'
  | 'noActiveGame'
  | 'invalidCharacters'
  | 'notInWordList'
  | 'failedToStart'
  | 'home'
  | 'viewStats'
  | 'gamesPlayed'
  | 'winRate'
  | 'currentStreak'
  | 'bestStreak'
  | 'dataCleared'
  | 'failedToClear'
  | 'statistics'
  | 'guessDistribution'
  | 'avgGuesses'
  | 'lastPlayed'
  | 'gamesWon'
  | 'confirmDelete'
  | 'cancel'
  | 'clearGameData'
  | 'pressEnterNewGame'
  | 'infinite'
  | 'wordOfTheDay'
  | 'todaysSet'
  | 'loading';

export type TranslationParams = Record<string, string | number>;
--- End of File: lib/types/i18n.ts ---

--- File: lib/types/keyboard.ts (Words (approx tokens): 392) ---

export type KeyboardLayout = 'qwerty' | 'azerty';
export type KeyState = 'correct' | 'present' | 'absent' | 'empty';
export type KeyboardKey = {
  key: string;
  state: KeyState | 'unused';
};

export const KEYBOARD_LAYOUTS: Record<KeyboardLayout, KeyboardKey[][]> = {
  qwerty: [
    [
      { key: 'q', state: 'empty' },
      { key: 'w', state: 'empty' },
      { key: 'e', state: 'empty' },
      { key: 'r', state: 'empty' },
      { key: 't', state: 'empty' },
      { key: 'y', state: 'empty' },
      { key: 'u', state: 'empty' },
      { key: 'i', state: 'empty' },
      { key: 'o', state: 'empty' },
      { key: 'p', state: 'empty' },
    ],
    [
      { key: 'a', state: 'empty' },
      { key: 's', state: 'empty' },
      { key: 'd', state: 'empty' },
      { key: 'f', state: 'empty' },
      { key: 'g', state: 'empty' },
      { key: 'h', state: 'empty' },
      { key: 'j', state: 'empty' },
      { key: 'k', state: 'empty' },
      { key: 'l', state: 'empty' },
    ],
    [
      { key: 'Enter', state: 'empty' },
      { key: 'z', state: 'empty' },
      { key: 'x', state: 'empty' },
      { key: 'c', state: 'empty' },
      { key: 'v', state: 'empty' },
      { key: 'b', state: 'empty' },
      { key: 'n', state: 'empty' },
      { key: 'm', state: 'empty' },
      { key: 'Backspace', state: 'empty' },
    ],
  ],
  azerty: [
    [
      { key: 'a', state: 'empty' },
      { key: 'z', state: 'empty' },
      { key: 'e', state: 'empty' },
      { key: 'r', state: 'empty' },
      { key: 't', state: 'empty' },
      { key: 'y', state: 'empty' },
      { key: 'u', state: 'empty' },
      { key: 'i', state: 'empty' },
      { key: 'o', state: 'empty' },
      { key: 'p', state: 'empty' },
    ],
    [
      { key: 'q', state: 'empty' },
      { key: 's', state: 'empty' },
      { key: 'd', state: 'empty' },
      { key: 'f', state: 'empty' },
      { key: 'g', state: 'empty' },
      { key: 'h', state: 'empty' },
      { key: 'j', state: 'empty' },
      { key: 'k', state: 'empty' },
      { key: 'l', state: 'empty' },
      { key: 'm', state: 'empty' },
    ],
    [
      { key: 'Enter', state: 'empty' },
      { key: 'w', state: 'empty' },
      { key: 'x', state: 'empty' },
      { key: 'c', state: 'empty' },
      { key: 'v', state: 'empty' },
      { key: 'b', state: 'empty' },
      { key: 'n', state: 'empty' },
      { key: 'Backspace', state: 'empty' },
    ],
  ],
};
--- End of File: lib/types/keyboard.ts ---

--- File: lib/utils/animations.ts (Words (approx tokens): 375) ---
export const ANIMATION_DURATION = 0.2;
export const FLIP_ANIMATION_DURATION = 500;
export const BOUNCE_ANIMATION_DURATION = 100;

export const getTileAnimationDelay = (index: number) => index * 0.1;

export const getTileAnimationConfig = (index: number) => ({
  flip: {
    duration: FLIP_ANIMATION_DURATION,
    delay: index * 100,
  },
  bounce: {
    duration: BOUNCE_ANIMATION_DURATION,
    type: "spring",
    stiffness: 200,
    damping: 15
  }
});

export const ANIMATIONS = {
  FLIP: {
    duration: 0.6,
    scale: [1, 1.1, 1],
    rotateX: [0, 90, 0],
  },
  SHAKE: {
    x: [0, -10, 10, -10, 10, 0],
    transition: { duration: 0.4 },
  },
  POP: {
    scale: [1, 1.1, 1],
    transition: { duration: 0.15 },
  },
  BOUNCE: {
    y: [0, -20, 0],
    transition: {
      type: "spring",
      stiffness: 300,
      damping: 10
    }
  },
  REVEAL: {
    initial: { opacity: 0, scale: 0.9 },
    animate: {  opacity: 1, scale: 1 },
    transition: { duration: 0.4, ease: "easeOut" }
  },
  TOAST: {
    initial: { opacity: 0, y: -20 },
    animate: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -20 },
    transition: { duration: 0.2 }
  }
};

export const KEYBOARD_ANIMATIONS = {
  PRESS: {
    scale: [1, 0.9, 1],
    transition: { duration: 0.1 }
  },
  CORRECT: {
    backgroundColor: ["#4b5563", "#22c55e"],
    transition: { duration: 0.5 }
  },
  PRESENT: {
    backgroundColor: ["#4b5563", "#eab308"],
    transition: { duration: 0.5 }
  },
  ABSENT: {
    backgroundColor: ["#4b5563", "#6b7280"],
    transition: { duration: 0.5 }
  }
};

export const MENU_ANIMATIONS = {
  CONTAINER: {
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 },
    transition: { duration: 0.3 }
  },
  BUTTON: {
    whileHover: { scale: 1.05 },
    whileTap: { scale: 0.95 },
    transition: { type: "spring", stiffness: 400, damping: 17 }
  },
  BUTTON_EXTRA: {
    whileHover: { y: -2 },
    whileTap: { y: 0 },
    transition: { type: "spring", stiffness: 400, damping: 17 }
  }
};

export const STATS_ANIMATIONS = {
  COUNT: {
    initial: { value: 0 },
    animate: { value: 1 },
    transition: { duration: 1, ease: "easeOut" }
  }
};

export const TITLE_ANIMATIONS = {
  CONTAINER: {
    initial: { opacity: 0, y: 20 },
    animate: { opacity: 1, y: 0 },
    transition: { duration: 0.8, ease: "easeOut", delay: 0.2 }
  },
  CELL: {
    initial: { scale: 0.8, opacity: 0 },
    animate: { scale: 1, opacity: 1 },
    transition: { duration: 0.4, ease: "backOut" }
  }
};

--- End of File: lib/utils/animations.ts ---

--- File: lib/utils/keyboard.ts (Words (approx tokens): 71) ---
import { GuessResult } from '@/lib/types/game';
import { KeyState } from '@/lib/types/keyboard';

export function getKeyboardState(
  guesses: GuessResult[]
): Record<string, KeyState> {
  const keyStates: Record<string, KeyState> = {};

  guesses.forEach((guess) => {
    guess.word.toLowerCase().split('').forEach((letter, letterIndex) => {
      const currentState = guess.letterStates[letterIndex];
      
      // Only update if the new state is "better"
      if (!keyStates[letter] || 
          (currentState === 'correct') ||
          (currentState === 'present' && keyStates[letter] === 'absent')) {
        keyStates[letter] = currentState;
      }
    });
  });

  return keyStates;
}



--- End of File: lib/utils/keyboard.ts ---

--- File: lib/utils/storage.ts (Words (approx tokens): 460) ---
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import { Language } from '@/lib/types/i18n';
import type { GuessResult, GameMode } from '@/lib/types/game';

// Utility for combining Tailwind classes
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Generic localStorage helpers
export function saveGameState<T>(key: string, value: T): void {
  if (typeof window !== 'undefined') {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Failed to save game state for key ${key}:`, error);
    }
  }
}

export function loadGameState<T>(key: string, defaultValue: T): T {
  if (typeof window === 'undefined') return defaultValue;
  
  try {
    const saved = window.localStorage.getItem(key);
    return saved ? JSON.parse(saved) : defaultValue;
  } catch (error) {
    console.error(`Failed to load game state for key ${key}:`, error);
    return defaultValue;
  }
}

export interface DailyGameState {
  date: string;
  guesses: GuessResult[];
  revealedAnswer: string | null;
}

export function saveDailyGameState(gameMode: GameMode, state: DailyGameState): void {
  if (typeof window !== 'undefined') {
    if (gameMode === 'infinite') return; // Don't save for infinite mode
    const key = `lexic-daily-game-${gameMode}`;
    try {
      window.localStorage.setItem(key, JSON.stringify(state));
    } catch (error) {
      console.error(`Failed to save daily game state for ${gameMode}:`, error);
    }
  }
}

export function loadDailyGameState(gameMode: GameMode): DailyGameState | null {
  if (typeof window === 'undefined' || gameMode === 'infinite') return null;
  
  const key = `lexic-daily-game-${gameMode}`;
  try {
    const saved = window.localStorage.getItem(key);
    return saved ? JSON.parse(saved) as DailyGameState : null;
  } catch (error)    {
    console.error(`Failed to load daily game state for ${gameMode}:`, error);
    return null;
  }
}

export function clearDailyGameState(gameMode: GameMode): void {
  if (typeof window !== 'undefined') {
    if (gameMode === 'infinite') return;
    const key = `lexic-daily-game-${gameMode}`;
    try {
      window.localStorage.removeItem(key);
    } catch (error) {
      console.error(`Failed to clear daily game state for ${gameMode}:`, error);
    }
  }
}


// Add to lib/utils/storage.ts
export function clearAllGameData(): void {
  if (typeof window === 'undefined') return;
  
  try {
    // Clear all localStorage data
    localStorage.clear();
    
    window.dispatchEvent(new Event('storage'));
  } catch (error) {
    console.error('Failed to clear game data:', error);
    throw new Error('Failed to clear game data');
  }
}

const STORAGE_KEYS = {
  STATS: 'lexic-stats',
  CURRENT_GAME: 'lexic-current-game',
  KEYBOARD: 'keyboard-layout',
  LANGUAGE: 'language-preference'
} as const;

export function saveLanguagePreference(language: Language): void {
  if (typeof window !== 'undefined') {
    try {
      localStorage.setItem(STORAGE_KEYS.LANGUAGE, language);
      // Remove old key if it exists
      localStorage.removeItem('language');
    } catch (error) {
      console.error('Failed to save language preference:', error);
    }
  }
}

export function loadLanguagePreference(): Language {
  if (typeof window === 'undefined') return 'en';
  
  try {
    // Try to get from new key first
    let saved = localStorage.getItem(STORAGE_KEYS.LANGUAGE);
    
    // If not found, check old key and migrate
    if (!saved) {
      const oldSaved = localStorage.getItem('language');
      if (oldSaved) {
        saved = oldSaved;
        // Migrate to new key
        localStorage.setItem(STORAGE_KEYS.LANGUAGE, oldSaved);
        localStorage.removeItem('language');
      }
    }
    
    return (saved === 'fr' || saved === 'en') ? saved : 'en';
  } catch (error) {
    console.error('Failed to load language preference:', error);
    return 'en';
  }
}
--- End of File: lib/utils/storage.ts ---
